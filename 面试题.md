## 前端面试题

### 1.预编译习题 [文章地址](https://zhuanlan.zhihu.com/p/50236805)

```js
function fn(a, c) {
  console.log(a); // function a() {}
  var a = 123;
  console.log(a); // 123
  console.log(c); // function c() {}
  function a() {}
  if (false) {
    var d = 678;
  }
  console.log(d); // undefined
  console.log(b); // undefined
  var b = function () {}; // 这里b声明进行了域解析
  console.log(b); // function () {}
  function c() {}
  console.log(c);
}
fn(1, 2);

// 预编译
// 作用域的创建阶段 预编译阶段
// 预编译的时候做了哪些事情
// js的变量对象 AO对象 供js引擎自己去访问的
// 1 创建AO(Activation Object)对象
// 2 找形参和变量的声明 作为AO的属性名 值是undefined
// 3 实参和形参相统一
// 4 找函数声明 会覆盖变量声明
// GO (Global Object)
//
AO: {
  a: undefined 1 function a() {}
  c: undefined 2 function c() {}
  b: undefined
  d: undefined
  b: undefined
}
// js的解析执行 逐行执行
```

### 2. js this 指向

#### 在函数中直接使用

```js
function get(content) {
  console.log(content);
}
get("您好");
get.call(window, "您好");
```

#### 函数作为对象的方法被调用(谁调用我 我就指向谁)

```js
 var person = {
   name: '张三',
   run(time) {
     console.log(`${this.name} 在跑步 最多${time}min就不行了`)
   }
   person.run(30)
   person.run.call(person, 30)
 }
```

```js
// 1.函数的直接调用 this指向window
// 2. 作为对象的方法调用 this指向该对象
// 阿里笔试题
var name = 222;
var a = {
  name: 111,
  say() {
    console.log(this.name);
  },
};
var fun = a.say;
fun(); // fun.call(window) 222
a.say(); // a.say.call(a)  111

var b = {
  name: 333,
  say(fun) {
    fun(); // fun.call(window)
  },
};
b.say(a.say);
b.say = a.say;
b.say();
```

#### 箭头函数中的 this

- 箭头函数中的 this 是定义在函数的时候绑定的，而不是在执行函数的时候绑定。
- 箭头函数中，this 执行的固定化，并不是因为箭头函数内部有绑定 this 的机制，实际原有是箭头函数根本没有自己的 this,导致内部的 this 就是外层的代码块的 this。正是因为它没有 this。所以就**不能用作构造函数**
- 箭头函数中的 this 是定义函数的时候绑定

```js
var x = 11;
var obj = {
  x: 22,
  say: () => {
    console.log(this.x);
  },
};
obj.say(); // 11
```

- 所谓的定义时候绑定，就是 this 是继承自父执行上下文中的 this，比如这里的箭头函数中的 this.x，函数本身与 say 平级以 key:value 的形式，也就是箭头函数本身所在的对象为 obj，而 obj 的父执行上下文就是 window，因此这里的 this.x 实际上表示 window.x，因此输出的是 11

```js
var obj = {
  birth: 1990,
  getAge() {
    var b = this.birth;
    var fn = () => new Date().getFullYear() - this.birth;
    return fn();
  },
};
obj.getAge(); // 31
```

- 例子中箭头函数本身是在 getAge 方法中定义的，因此，getAge 方法的父执行上下文是 obj，因此这里的 this 指向则为 obj

### 浅拷贝 深拷贝

#### 目标

1. 什么是浅拷贝
2. 实现的方式
3. 在 vue 中的使用

#### 前置知识

- js 的一般数据类型的存储
- js 的引用类型的数据存储

- 浅拷贝是创建一个新对象，这个对象有着原始的对象属性的一份精确拷贝。**如果属性是基本类型，拷贝的就是基本类型的值**，**如果属性是引用类型，拷贝的就是内存地址**，所以如果其中一个对象改变了这个地址，就会影响到另一个对象。

- 深拷贝是将一个对象从内存中完整的拷贝一份出来，从堆内存开辟一个新的区域存放新对象，且修改新对象不会影响原对象。

#### 针对引用类型来说 赋值 深拷贝 浅拷贝的区别

1. 浅拷贝 赋值的区别

- 当我们把一个对象赋值给一个新的变量时，赋值的其实是该对象的在栈中的地址，而不是堆中的数据。也就是两个对象指向的是同一个存储空间，无论哪个对象发生改变，其实都是改变的存储空间的内容，因此，两个对象是联动的。

- 浅拷贝：重新在堆中创建内存，拷贝前后对象的基本数据类型互不影响，但拷贝前后对象的引用类型共享一块内存，会相互影响。
- 深拷贝：从堆内存中开辟一个新的区域存放对象，对对象中的子对象进行递归澳贝，拷贝前后的两个对象互不影响。

#### 深拷贝的实现方式

- JSON.parse(JSON.stringify())：只能序列化对象的可枚举的自有属性，例如 如果 obj 中的对象是有构造函数生成的， 则使用 JSON.parse(JSON.stringify(obj))深拷贝后，会丢弃对象的 constructor；
- 递归操作
- deepClone
- Jquery.extend()


date: new RegExp('\\w+')

data: [new Date(1625501533431), new Date(1625501533431)]

| Javascript拷贝 | 和原数据是否指向同一对象 | 第一层数据为一般数据类型       | 第一次数据不是原始类型         |
| ---------------------- | ------------------------ | ------------------------------ | ------------------------------ |
| 赋值                     | 是                       | 改变会使原始数据一同改变       | 改变会使原始数据一同改变       |
| 浅拷贝                   | 否                       | 改变不会使原始数据类型改变     | 改变会使数据一同改变           |
| 深拷贝                   | 否                       | 改变不会使原始数据类型一同改变 | 改变不会使原始数据类型一同改变 |

### 防抖节流

当持续触发事件 一定时间内没有再触发事件 事件处理函数才会执行一次。如果设定的时间到来之前 又一次触发了事件 就重新开始延时

触发事件 一段时间内 没有触发 事件执行 肯定是定时器
(在设定的时间内 又一次触发了事件 重新开始延时 代表的就是重新开始的定时器)
(那么意味着上一次还没有结束的定时器要清除掉 重新开始)
````js
let timer
clearTimeout(timer)
timer = setTimeout(function () {}, delay)
````

#### 实际应用
使用echarts，改变浏览宽度的时候，希望重新渲染。
echarts的图像，可以使用此函数，提升性能。(虽然echarts里有自带的resize函数)
典型的案例就是输入搜索：输入结束后n秒才进行搜索请求，n秒内又输入的内容, 就重新计时。
解决搜索的bug， 拿到键盘停下那一刻输入的值进行搜索


### 节流

当持续触发事件的时候 保证一段时间内 只调用一次事件处理函数
一段时间内 只做一件事情

### 实际应用 表单的提交
典型的案例就是鼠标不断点击触发按钮，规定在n秒内多次点击只有一次生效。
